export const detectVulnerabilities = (contractCode) => {
  const vulnerabilities = [];
  const lines = contractCode.split('\n');

  lines.forEach((line, index) => {
    const lineNumber = index + 1;
    const trimmedLine = line.trim();

    if (trimmedLine.includes('.call(') && !trimmedLine.includes('require(')) {
      vulnerabilities.push({
        type: 'Reentrancy',
        severity: 'High',
        line: lineNumber,
        description: 'Low-level call without proper checks - potential reentrancy vulnerability',
        code: trimmedLine
      });
    }

    if (trimmedLine.includes('tx.origin')) {
      vulnerabilities.push({
        type: 'tx.origin Usage',
        severity: 'Medium',
        line: lineNumber,
        description: 'Using tx.origin for authorization is vulnerable to phishing attacks',
        code: trimmedLine
      });
    }

    if (trimmedLine.includes('selfdestruct') || trimmedLine.includes('suicide')) {
      vulnerabilities.push({
        type: 'Destructive Operation',
        severity: 'High',
        line: lineNumber,
        description: 'Contract can be destroyed - ensure proper access controls',
        code: trimmedLine
      });
    }

    if (/\+\+|\-\-/.test(trimmedLine) && !trimmedLine.includes('SafeMath')) {
      vulnerabilities.push({
        type: 'Integer Overflow',
        severity: 'Medium',
        line: lineNumber,
        description: 'Arithmetic operation without overflow protection',
        code: trimmedLine
      });
    }

    if (trimmedLine.includes('block.timestamp') || trimmedLine.includes('now')) {
      vulnerabilities.push({
        type: 'Timestamp Dependence',
        severity: 'Low',
        line: lineNumber,
        description: 'Timestamp can be manipulated by miners within limits',
        code: trimmedLine
      });
    }
  });

  return vulnerabilities;
};

export const calculateSecurityScore = (vulnerabilities) => {
  let score = 100;

  vulnerabilities.forEach(vuln => {
    switch (vuln.severity) {
      case 'High':
        score -= 25;
        break;
      case 'Medium':
        score -= 15;
        break;
      case 'Low':
        score -= 5;
        break;
      default:
        break;
    }
  });

  return Math.max(0, score);
};